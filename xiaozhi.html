<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>N·∫°p Firmware ESP32 qua WebSerial</title>

  <!-- Bundle ch√≠nh th·ª©c c·ªßa esptool-js -->
  <script src="https://unpkg.com/esptool-js/bundle.js"></script>

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      max-width: 600px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      margin: 4px 4px 4px 0;
      cursor: pointer;
    }
    #log {
      white-space: pre-wrap;
      background: #fff;
      padding: 10px;
      margin-top: 16px;
      border: 1px solid #ccc;
      height: 260px;
      overflow-y: auto;
      font-size: 12px;
    }
    input[type="file"] {
      margin: 8px 0;
    }
    .hint {
      font-size: 12px;
      color: #555;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <h1>N·∫°p Firmware ESP32-S3</h1>
  <p class="hint">
    ‚ö† M·ªü trang n√†y b·∫±ng <b>Chrome</b> tr√™n <code>http://localhost</code> (kh√¥ng ph·∫£i <code>file://</code>).
  </p>

  <div>
    <label>Firmware (.bin): </label>
    <input type="file" id="firmware" accept=".bin" />
  </div>

  <button id="connect">1Ô∏è‚É£ K·∫øt n·ªëi ESP32</button>
  <button id="flash">2Ô∏è‚É£ N·∫°p firmware</button>

  <div id="log"></div>

  <script>
    const logEl = document.getElementById("log");
    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    // Ki·ªÉm tra esptool-js ƒë√£ load ch∆∞a
    function getEsptool() {
      if (window.esptooljs) return window.esptooljs;
      log("‚ùå Kh√¥ng t√¨m th·∫•y window.esptooljs ‚Äì bundle ch∆∞a load ƒë√∫ng?");
      return null;
    }

    let transport = null;
    let loader = null;
    let serialPort = null;

    // Terminal ƒë·ªÉ esptool-js ghi log ra UI
    const terminal = {
      clean() {},
      writeLine(data) { log(data); },
      write(data) { log(data); }
    };

    const connectBtn = document.getElementById("connect");
    const flashBtn = document.getElementById("flash");

    connectBtn.onclick = async () => {
      try {
        const esptool = getEsptool();
        if (!esptool) return;

        if (!("serial" in navigator)) {
          log("‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Serial (d√πng Chrome / Edge).");
          return;
        }

        log("üîå Ch·ªçn c·ªïng serial c·ªßa ESP32-S3...");
        serialPort = await navigator.serial.requestPort({});
        // Transport s·∫Ω t·ª± qu·∫£n l√Ω open/close
        transport = new esptool.Transport(serialPort);

        loader = new esptool.ESPLoader({
          transport,
          baudrate: 115200,
          romBaudrate: 115200,
          terminal,
          debugLogging: true,
          enableTracing: false,
        });

        log("üîÑ ƒêang c·ªë g·∫Øng k·∫øt n·ªëi & sync bootloader...");
        await loader.main();    // gi·ªëng esp-web-tools d√πng ƒë·ªÉ init chip :contentReference[oaicite:3]{index=3}
        await loader.flashId();

        log(`‚úÖ ƒê√£ k·∫øt n·ªëi: ${loader.chip.CHIP_NAME}`);
      } catch (e) {
        console.error(e);
        log("‚ùå L·ªói k·∫øt n·ªëi: " + (e?.message || e));
      }
    };

    flashBtn.onclick = async () => {
      try {
        if (!loader || !transport) {
          log("‚ö† Ch∆∞a k·∫øt n·ªëi ESP32. Nh·∫•n 'K·∫øt n·ªëi ESP32' tr∆∞·ªõc.");
          return;
        }

        const fileInput = document.getElementById("firmware");
        const file = fileInput.files[0];
        if (!file) {
          log("‚ö† H√£y ch·ªçn file .bin tr∆∞·ªõc.");
          return;
        }

        log(`üìÅ Firmware: ${file.name}`);
        // esptool-js mong data l√† binary string, kh√¥ng ph·∫£i Uint8Array :contentReference[oaicite:4]{index=4}
        const reader = new FileReader();
        reader.readAsBinaryString(file);

        reader.onload = async () => {
          const data = reader.result; // string
          const totalSize = data.length;

          log("üßÆ Chu·∫©n b·ªã n·∫°p firmware...");

          let lastPct = 0;
          await loader.writeFlash({
            fileArray: [
              {
                // offset 0x0: d√πng khi anh build ra 1 file merge (bootloader + partition + app)
                // n·∫øu ch·ªâ l√† app.bin th√¨ offset th∆∞·ªùng l√† 0x10000
                data,
                address: 0x0,
              },
            ],
            flashSize: "keep",
            flashMode: "keep",
            flashFreq: "keep",
            eraseAll: false,
            compress: true,
            reportProgress: (fileIndex, written, total) => {
              const pct = Math.floor((written / total) * 100);
              if (pct !== lastPct) {
                lastPct = pct;
                log(`‚úèÔ∏è ƒêang n·∫°p: ${pct}%`);
              }
            },
          });

          log("‚úÖ N·∫°p xong firmware!");
          log("üîÅ ƒêang reset thi·∫øt b·ªã...");
          try {
            await serialPort.setSignals({
              dataTerminalReady: false,
              requestToSend: true,
            });
            await new Promise((r) => setTimeout(r, 250));
            await serialPort.setSignals({
              dataTerminalReady: false,
              requestToSend: false,
            });
          } catch (_) {}

          await transport.disconnect();
          log("üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi.");
        };

        reader.onerror = (e) => {
          log("‚ùå L·ªói ƒë·ªçc file: " + e);
        };
      } catch (e) {
        console.error(e);
        log("‚ùå L·ªói n·∫°p firmware: " + (e?.message || e));
      }
    };
  </script>
</body>
</html>

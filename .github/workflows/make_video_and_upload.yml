name: "TTS + Video TikTok/YouTube -> Telegram"

on:
  repository_dispatch:
    types: [tts_dual_text_to_telegram]
  workflow_dispatch:
    inputs:
      summary:
        description: "Summary text (shown on video)"
        required: true
      full:
        description: "Full text (used for TTS audio)"
        required: true
      voice:
        description: "TTS voice"
        required: false
        default: "vi-VN-HoaiMyNeural"

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq curl fonts-noto-core fontconfig python3 python3-pip
          python3 -m pip install --upgrade pip
          python3 -m pip install moviepy pillow numpy

      - name: Write inputs to files (safe)
        env:
          SUMMARY_DISPATCH: ${{ github.event.client_payload.summary }}
          FULL_DISPATCH: ${{ github.event.client_payload.full }}
          VOICE_DISPATCH: ${{ github.event.client_payload.voice }}
          SUMMARY_INPUT: ${{ inputs.summary }}
          FULL_INPUT: ${{ inputs.full }}
          VOICE_INPUT: ${{ inputs.voice }}
        run: |
          set -euo pipefail
          mkdir -p work
          python3 - <<'PY'
          import os
          summary = os.environ.get("SUMMARY_DISPATCH") or os.environ.get("SUMMARY_INPUT") or ""
          full = os.environ.get("FULL_DISPATCH") or os.environ.get("FULL_INPUT") or ""
          voice = os.environ.get("VOICE_DISPATCH") or os.environ.get("VOICE_INPUT") or "vi-VN-HoaiMyNeural"
          if not summary.strip():
            raise SystemExit("Missing summary")
          if not full.strip():
            raise SystemExit("Missing full")
          open("work/summary.txt","w",encoding="utf-8").write(summary.strip()+"\n")
          open("work/full.txt","w",encoding="utf-8").write(full.strip()+"\n")
          open("work/voice.txt","w",encoding="utf-8").write(voice.strip()+"\n")
          print("OK: wrote summary/full/voice")
          PY

      - name: Prepare title + upload.txt
        id: prep
        run: |
          set -euo pipefail
          export TZ=Asia/Tokyo
          DATE="$(date +%Y-%m-%d)"
          SUMMARY_ONELINE="$(python3 - <<'PY'
          import re
          s=open("work/summary.txt","r",encoding="utf-8").read().strip()
          s=re.sub(r"\s+"," ",s)
          print(s)
          PY
          )"
          SHORT="$(python3 - <<PY
          s = """$SUMMARY_ONELINE"""
          print((s[:60] + "…") if len(s) > 60 else s)
          PY
          )"
          TITLE="${DATE} ${SHORT}"
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          cat > work/upload.txt <<EOF
          Title: $TITLE
          Date: $DATE

          Summary:
          $SUMMARY_ONELINE

          Full text:
          $(cat work/full.txt)
          EOF

      - name: Generate TTS from full text (mp3)
        run: |
          set -euo pipefail
          VOICE="$(cat work/voice.txt)"
          curl -sS -X POST "https://mcp-xiaozhi.vercel.app/api/tts/stream" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg text "$(cat work/full.txt)" --arg voice "$VOICE" --arg format "mp3" '{text:$text, voice:$voice, format:$format}')" \
            --output work/tts.mp3
          if [ ! -s work/tts.mp3 ]; then
            echo "tts.mp3 is empty. TTS request failed."
            exit 1
          fi

      - name: Wrap summary text for video
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import re
          src = open("work/summary.txt","r",encoding="utf-8").read().strip()
          src = re.sub(r"\s+"," ",src)
          def wrap(src, max_chars=26, max_lines=7):
            words = src.split(" ")
            lines, cur = [], []
            for w in words:
              if sum(len(x) for x in cur) + len(cur) + len(w) <= max_chars:
                cur.append(w)
              else:
                lines.append(" ".join(cur))
                cur = [w]
            if cur: lines.append(" ".join(cur))
            if len(lines) > max_lines:
              lines = lines[:max_lines-1] + ["… " + lines[max_lines-1]]
            return "\n".join(lines)
          open("work/summary_wrapped_tiktok.txt","w",encoding="utf-8").write(wrap(src, 26, 7))
          open("work/summary_wrapped_youtube.txt","w",encoding="utf-8").write(wrap(src, 38, 5))
          PY

      - name: Pick random colors + effect (many)
        id: theme
        run: |
          set -euo pipefail
          BG1_LIST=( "#0B1026" "#120B2E" "#052B2B" "#1B1020" "#0C1B2A" "#19140D" )
          BG2_LIST=( "#3A7BD5" "#7B2FF7" "#00C6A7" "#FF4D6D" "#F7B733" "#2BC0E4" "#F857A6" "#00F5A0" )
          TXT_LIST=( "#FFFFFF" "#EAF2FF" "#FFF7E6" "#E7FFE8" "#F3E8FF" "#FFEAF1" "#F6FFFE" )
          BG1="${BG1_LIST[$((RANDOM % ${#BG1_LIST[@]}))]}"
          BG2="${BG2_LIST[$((RANDOM % ${#BG2_LIST[@]}))]}"
          TXT="${TXT_LIST[$((RANDOM % ${#TXT_LIST[@]}))]}"
          EFFECTS=(rain snow fireworks confetti bokeh stars bubbles scanlines sparkle)
          EFFECT="${EFFECTS[$((RANDOM % ${#EFFECTS[@]}))]}"
          echo "bg1=$BG1" >> "$GITHUB_OUTPUT"
          echo "bg2=$BG2" >> "$GITHUB_OUTPUT"
          echo "txt=$TXT" >> "$GITHUB_OUTPUT"
          echo "effect=$EFFECT" >> "$GITHUB_OUTPUT"
          echo "Theme: bg1=$BG1 bg2=$BG2 txt=$TXT effect=$EFFECT"

      - name: Render videos with MoviePy (TikTok + YouTube)
        env:
          BG1: ${{ steps.theme.outputs.bg1 }}
          BG2: ${{ steps.theme.outputs.bg2 }}
          TXT: ${{ steps.theme.outputs.txt }}
          EFFECT: ${{ steps.theme.outputs.effect }}
        run: |
          python3 - << 'PYSCRIPT'
          import os, random, math
          from PIL import Image, ImageDraw, ImageFont, ImageFilter
          import numpy as np
          from moviepy.editor import ImageSequenceClip, AudioFileClip, CompositeVideoClip, VideoClip
          from moviepy.video.fx.all import fadein, fadeout

          # Get env vars
          bg1 = os.environ['BG1']
          bg2 = os.environ['BG2']
          txt_color = os.environ['TXT']
          effect = os.environ['EFFECT']
          
          # Read summary text
          with open('work/summary_wrapped_tiktok.txt', 'r', encoding='utf-8') as f:
              text_tiktok = f.read()
          with open('work/summary_wrapped_youtube.txt', 'r', encoding='utf-8') as f:
              text_youtube = f.read()
          
          # Get audio duration
          audio = AudioFileClip('work/tts.mp3')
          duration = audio.duration
          fps = 30
          total_frames = int(duration * fps)
          
          def hex_to_rgb(hex_color):
              hex_color = hex_color.lstrip('#')
              return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
          
          rgb1 = hex_to_rgb(bg1)
          rgb2 = hex_to_rgb(bg2)
          txt_rgb = hex_to_rgb(txt_color)
          
          # Particle systems for different effects
          class ParticleSystem:
              def __init__(self, width, height, effect_type):
                  self.width = width
                  self.height = height
                  self.effect = effect_type
                  self.particles = []
                  self.init_particles()
              
              def init_particles(self):
                  if self.effect == 'rain':
                      for _ in range(80):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': random.uniform(-self.height, 0),
                              'speed': random.uniform(15, 25),
                              'length': random.uniform(15, 30),
                              'opacity': random.randint(80, 180)
                          })
                  elif self.effect == 'snow':
                      for _ in range(100):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': random.uniform(-self.height, 0),
                              'speed': random.uniform(1, 3),
                              'size': random.uniform(2, 6),
                              'drift': random.uniform(-0.5, 0.5),
                              'opacity': random.randint(100, 200)
                          })
                  elif self.effect == 'confetti':
                      for _ in range(60):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': random.uniform(-self.height, 0),
                              'speed': random.uniform(2, 5),
                              'rotation': random.uniform(0, 360),
                              'rot_speed': random.uniform(-10, 10),
                              'color': tuple(random.randint(100, 255) for _ in range(3)),
                              'size': random.uniform(3, 8)
                          })
                  elif self.effect == 'bokeh':
                      for _ in range(30):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': random.uniform(0, self.height),
                              'size': random.uniform(20, 60),
                              'speed_y': random.uniform(0.3, 1),
                              'opacity': random.randint(30, 80),
                              'color': tuple(random.randint(150, 255) for _ in range(3))
                          })
                  elif self.effect == 'stars':
                      for _ in range(80):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': random.uniform(0, self.height),
                              'size': random.uniform(1, 4),
                              'twinkle_speed': random.uniform(0.05, 0.15),
                              'phase': random.uniform(0, math.pi * 2)
                          })
                  elif self.effect == 'bubbles':
                      for _ in range(40):
                          self.particles.append({
                              'x': random.uniform(0, self.width),
                              'y': self.height + random.uniform(0, 200),
                              'size': random.uniform(10, 30),
                              'speed': random.uniform(1, 3),
                              'drift': random.uniform(-0.3, 0.3),
                              'opacity': random.randint(60, 120)
                          })
                  elif self.effect == 'fireworks':
                      # Fireworks spawn dynamically
                      pass
              
              def update(self, frame):
                  if self.effect == 'rain':
                      for p in self.particles:
                          p['y'] += p['speed']
                          if p['y'] > self.height:
                              p['y'] = -50
                              p['x'] = random.uniform(0, self.width)
                  elif self.effect == 'snow':
                      for p in self.particles:
                          p['y'] += p['speed']
                          p['x'] += p['drift']
                          if p['y'] > self.height:
                              p['y'] = -20
                              p['x'] = random.uniform(0, self.width)
                  elif self.effect == 'confetti':
                      for p in self.particles:
                          p['y'] += p['speed']
                          p['rotation'] += p['rot_speed']
                          if p['y'] > self.height:
                              p['y'] = -20
                              p['x'] = random.uniform(0, self.width)
                  elif self.effect == 'bokeh':
                      for p in self.particles:
                          p['y'] += p['speed_y']
                          if p['y'] > self.height + 100:
                              p['y'] = -100
                  elif self.effect == 'bubbles':
                      for p in self.particles:
                          p['y'] -= p['speed']
                          p['x'] += p['drift']
                          if p['y'] < -50:
                              p['y'] = self.height + 50
                              p['x'] = random.uniform(0, self.width)
              
              def draw(self, img, frame):
                  draw = ImageDraw.Draw(img, 'RGBA')
                  
                  if self.effect == 'rain':
                      for p in self.particles:
                          draw.line([(p['x'], p['y']), (p['x'], p['y'] + p['length'])], 
                                   fill=(255, 255, 255, p['opacity']), width=2)
                  elif self.effect == 'snow':
                      for p in self.particles:
                          draw.ellipse([(p['x']-p['size'], p['y']-p['size']), 
                                       (p['x']+p['size'], p['y']+p['size'])],
                                      fill=(255, 255, 255, p['opacity']))
                  elif self.effect == 'confetti':
                      for p in self.particles:
                          x, y = p['x'], p['y']
                          size = p['size']
                          draw.rectangle([(x-size, y-size), (x+size, y+size)], 
                                        fill=p['color'] + (200,))
                  elif self.effect == 'bokeh':
                      for p in self.particles:
                          size = p['size']
                          draw.ellipse([(p['x']-size, p['y']-size), 
                                       (p['x']+size, p['y']+size)],
                                      fill=p['color'] + (p['opacity'],))
                  elif self.effect == 'stars':
                      for p in self.particles:
                          brightness = int(128 + 127 * math.sin(frame * p['twinkle_speed'] + p['phase']))
                          size = p['size']
                          draw.ellipse([(p['x']-size, p['y']-size), 
                                       (p['x']+size, p['y']+size)],
                                      fill=(255, 255, 255, brightness))
                  elif self.effect == 'bubbles':
                      for p in self.particles:
                          size = p['size']
                          draw.ellipse([(p['x']-size, p['y']-size), 
                                       (p['x']+size, p['y']+size)],
                                      outline=(255, 255, 255, p['opacity']), width=2)
                  elif self.effect == 'scanlines':
                      for y in range(0, self.height, 6):
                          offset = int((frame * 2) % 6)
                          draw.line([(0, (y + offset) % self.height), 
                                    (self.width, (y + offset) % self.height)], 
                                   fill=(0, 0, 0, 90), width=1)
          
          def create_gradient_bg(width, height, color1, color2):
              img = Image.new('RGB', (width, height))
              draw = ImageDraw.Draw(img)
              for y in range(height):
                  ratio = y / height
                  r = int(color1[0] * (1 - ratio) + color2[0] * ratio)
                  g = int(color1[1] * (1 - ratio) + color2[1] * ratio)
                  b = int(color1[2] * (1 - ratio) + color2[2] * ratio)
                  draw.line([(0, y), (width, y)], fill=(r, g, b))
              return img.filter(ImageFilter.GaussianBlur(20))
          
          def render_format(width, height, text, output_file):
              print(f"Rendering {width}x{height}...")
              
              # Try to load font
              try:
                  font = ImageFont.truetype("/usr/share/fonts/truetype/noto/NotoSans-Bold.ttf", 
                                           64 if width == 1080 else 56)
              except:
                  font = ImageFont.load_default()
              
              particle_sys = ParticleSystem(width, height, effect)
              
              frames = []
              for frame_num in range(total_frames):
                  # Create base gradient
                  img = create_gradient_bg(width, height, rgb1, rgb2)
                  
                  # Add vignette
                  vignette = Image.new('RGBA', (width, height), (0, 0, 0, 0))
                  vdraw = ImageDraw.Draw(vignette)
                  for i in range(min(width, height) // 4):
                      alpha = int(60 * (i / (min(width, height) // 4)))
                      vdraw.rectangle([i, i, width-i, height-i], outline=(0, 0, 0, alpha))
                  img = Image.alpha_composite(img.convert('RGBA'), vignette).convert('RGB')
                  
                  # Add particles
                  particle_overlay = Image.new('RGBA', (width, height), (0, 0, 0, 0))
                  particle_sys.update(frame_num)
                  particle_sys.draw(particle_overlay, frame_num)
                  img = Image.alpha_composite(img.convert('RGBA'), particle_overlay).convert('RGB')
                  
                  # Add text
                  text_overlay = Image.new('RGBA', (width, height), (0, 0, 0, 0))
                  tdraw = ImageDraw.Draw(text_overlay)
                  
                  # Draw text box background
                  bbox = tdraw.multiline_textbbox((0, 0), text, font=font)
                  text_width = bbox[2] - bbox[0]
                  text_height = bbox[3] - bbox[1]
                  box_x = (width - text_width) // 2 - 46
                  box_y = (height - text_height) // 2 - 46
                  tdraw.rectangle([box_x, box_y, box_x + text_width + 92, box_y + text_height + 92],
                                 fill=(0, 0, 0, 97))
                  
                  # Draw text with shadow
                  text_x = (width - text_width) // 2
                  text_y = (height - text_height) // 2
                  tdraw.multiline_text((text_x + 2, text_y + 2), text, font=font, 
                                      fill=(0, 0, 0, 64), align='center')
                  tdraw.multiline_text((text_x, text_y), text, font=font, 
                                      fill=txt_rgb, align='center')
                  
                  img = Image.alpha_composite(img.convert('RGBA'), text_overlay).convert('RGB')
                  
                  frames.append(np.array(img))
              
              # Create video
              clip = ImageSequenceClip(frames, fps=fps)
              clip = clip.set_audio(audio)
              
              # Add fade in/out
              clip = fadein(clip, 0.4)
              clip = fadeout(clip, 0.7)
              
              # Export
              clip.write_videofile(output_file, codec='libx264', audio_codec='aac',
                                  preset='veryfast', bitrate='2000k', threads=4)
              clip.close()
              print(f"Done: {output_file}")
          
          # Render both formats
          render_format(1080, 1920, text_tiktok, 'work/tiktok.mp4')
          render_format(1920, 1080, text_youtube, 'work/youtube.mp4')
          
          audio.close()
          PYSCRIPT

      - name: Upload to Telegram (caption = date + summary short)
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          TITLE: ${{ steps.prep.outputs.title }}
        run: |
          set -euo pipefail
          CAPTION="$TITLE"
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendVideo" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F video=@work/tiktok.mp4 | jq .
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendVideo" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F video=@work/youtube.mp4 | jq .
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F document=@work/upload.txt | jq .

      - name: Upload artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: outputs
          path: |
            work/tts.mp3
            work/tiktok.mp4
            work/youtube.mp4
            work/upload.txt

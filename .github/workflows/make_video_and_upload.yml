name: "TTS + Confetti Video TikTok/YouTube -> Telegram (puppeteer-core + xvfb, record 60s + loop)"

on:
  repository_dispatch:
    types: [tts_dual_text_to_telegram]
  workflow_dispatch:
    inputs:
      summary:
        description: "Summary text (shown on video)"
        required: true
      full:
        description: "Full text (used for TTS audio)"
        required: true
      background_url:
        description: "Background image URL"
        required: true
      voice:
        description: "TTS voice"
        required: false
        default: "vi-VN-HoaiMyNeural"

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      PUPPETEER_SKIP_DOWNLOAD: "true"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools (ffmpeg + chromium + xvfb)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq curl fonts-noto-core fontconfig python3 chromium-browser xvfb
          which chromium-browser || true
          which chromium || true
          chromium-browser --version || true
          chromium --version || true

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install npm deps (puppeteer-core + puppeteer-stream + canvas-confetti)
        run: |
          set -euo pipefail
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi

      - name: Write inputs to files (safe)
        env:
          SUMMARY_DISPATCH: ${{ github.event.client_payload.summary }}
          FULL_DISPATCH: ${{ github.event.client_payload.full }}
          BG_URL_DISPATCH: ${{ github.event.client_payload.background_url }}
          VOICE_DISPATCH: ${{ github.event.client_payload.voice }}
          SUMMARY_INPUT: ${{ inputs.summary }}
          FULL_INPUT: ${{ inputs.full }}
          BG_URL_INPUT: ${{ inputs.background_url }}
          VOICE_INPUT: ${{ inputs.voice }}
        run: |
          set -euo pipefail
          mkdir -p work
          python3 - <<'PY'
          import os
          summary = os.environ.get("SUMMARY_DISPATCH") or os.environ.get("SUMMARY_INPUT") or ""
          full = os.environ.get("FULL_DISPATCH") or os.environ.get("FULL_INPUT") or ""
          bg_url = os.environ.get("BG_URL_DISPATCH") or os.environ.get("BG_URL_INPUT") or ""
          voice = os.environ.get("VOICE_DISPATCH") or os.environ.get("VOICE_INPUT") or "vi-VN-HoaiMyNeural"
          if not summary.strip():
            raise SystemExit("Missing summary")
          if not full.strip():
            raise SystemExit("Missing full")
          if not bg_url.strip():
            raise SystemExit("Missing background_url")
          open("work/summary.txt","w",encoding="utf-8").write(summary.strip()+"\n")
          open("work/full.txt","w",encoding="utf-8").write(full.strip()+"\n")
          open("work/bg_url.txt","w",encoding="utf-8").write(bg_url.strip()+"\n")
          open("work/voice.txt","w",encoding="utf-8").write(voice.strip()+"\n")
          print("OK: wrote summary/full/bg_url/voice")
          PY

      - name: Prepare title + upload.txt
        id: prep
        run: |
          set -euo pipefail
          export TZ=Asia/Tokyo
          DATE="$(date +%Y-%m-%d)"
          python3 - <<'PY'
          import re
          s=open("work/summary.txt","r",encoding="utf-8").read().strip()
          s=re.sub(r"\s+"," ",s)
          short = (s[:60] + "â€¦") if len(s) > 60 else s
          open("work/summary_oneline.txt","w",encoding="utf-8").write(s+"\n")
          open("work/summary_short.txt","w",encoding="utf-8").write(short+"\n")
          PY
          SUMMARY_ONELINE="$(cat work/summary_oneline.txt)"
          SHORT="$(cat work/summary_short.txt)"
          TITLE="${DATE} ${SHORT}"
          echo "title=$TITLE" >> "$GITHUB_OUTPUT"
          cat > work/upload.txt <<EOF
          Title: $TITLE
          Date: $DATE

          Summary:
          $SUMMARY_ONELINE

          Full text:
          $(cat work/full.txt)
          EOF

      - name: Download background image
        run: |
          set -euo pipefail
          BG_URL="$(cat work/bg_url.txt)"
          curl -sS -L "$BG_URL" --output work/background.jpg
          if [ ! -s work/background.jpg ]; then
            echo "background.jpg download failed."
            exit 1
          fi

      - name: Generate TTS from full text (mp3)
        run: |
          set -euo pipefail
          VOICE="$(cat work/voice.txt)"
          curl -sS -X POST "https://mcp-xiaozhi.vercel.app/api/tts/stream" \
            -H "Content-Type: application/json" \
            -d "$(jq -n --arg text "$(cat work/full.txt)" --arg voice "$VOICE" --arg format "mp3" '{text:$text, voice:$voice, format:$format}')" \
            --output work/tts.mp3
          if [ ! -s work/tts.mp3 ]; then
            echo "tts.mp3 is empty. TTS request failed."
            exit 1
          fi

      - name: Create web scene + recorder script (local confetti, no CDN)
        run: |
          set -euo pipefail
          mkdir -p web scripts

          # local confetti bundle (no CDN/network)
          cp node_modules/canvas-confetti/dist/confetti.browser.js web/confetti.js

          cat > web/scene.html <<'HTML'
          <!doctype html>
          <html>
          <head>
            <meta charset="utf-8" />
            <link rel="icon" href="data:,">
            <style>
              html,body { margin:0; background:#000; overflow:hidden; }
              canvas { position:fixed; inset:0; width:100vw; height:100vh; }
              .overlay{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
              .box{
                color:#fff; font:700 56px system-ui, -apple-system, "Noto Sans", sans-serif;
                text-align:center; white-space:pre-wrap; line-height:1.25;
                background:rgba(0,0,0,.5); padding:36px 46px; border-radius:32px;
                max-width: 80vw;
                text-shadow: 0 2px 10px rgba(0,0,0,.7);
              }
            </style>
          </head>
          <body>
            <canvas id="c"></canvas>
            <div class="overlay"><div class="box" id="t"></div></div>

            <script src="./confetti.js"></script>
            <script>
              const params = new URLSearchParams(location.search);
              const W = Number(params.get("w") || 1080);
              const H = Number(params.get("h") || 1920);
              const text = params.get("text") || "";
              document.getElementById("t").textContent = text;

              const canvas = document.getElementById("c");
              const ctx = canvas.getContext("2d");
              canvas.width = W; canvas.height = H;

              const bg = new Image();
              bg.src = window.__BG__;
              bg.onload = () => requestAnimationFrame(loop);

              function drawBg(){
                const w = canvas.width, h = canvas.height;
                const scale = Math.max(w/bg.width, h/bg.height);
                const sw = bg.width * scale, sh = bg.height * scale;
                const sx = (w - sw)/2, sy = (h - sh)/2;
                ctx.drawImage(bg, sx, sy, sw, sh);
                ctx.fillStyle = "rgba(0,0,0,0.22)";
                ctx.fillRect(0,0,w,h);
              }

              const burst = () => confetti({
                particleCount: 120,
                spread: 120,
                startVelocity: 45,
                ticks: 220,
                origin: { x: Math.random()*0.8 + 0.1, y: Math.random()*0.4 + 0.2 }
              });

              let last = 0;
              function loop(ts){
                drawBg();
                if (ts - last > 800) { burst(); last = ts; }
                requestAnimationFrame(loop);
              }
            </script>
          </body>
          </html>
          HTML

          cat > scripts/record_60s.mjs <<'JS'
          import fs from "fs";
          import path from "path";
          import puppeteer from "puppeteer-core";
          import { getStream, wss } from "puppeteer-stream";

          const mode = process.argv[2] || "tiktok"; // tiktok|youtube
          const w = mode === "youtube" ? 1920 : 1080;
          const h = mode === "youtube" ? 1080 : 1920;

          const text = fs.readFileSync("work/summary_oneline.txt","utf8").trim();
          const bg = fs.readFileSync("work/background.jpg").toString("base64");
          const bgDataUrl = `data:image/jpeg;base64,${bg}`;

          const execPath =
            fs.existsSync("/usr/bin/chromium-browser") ? "/usr/bin/chromium-browser" :
            (fs.existsSync("/usr/bin/chromium") ? "/usr/bin/chromium" : "");
          if (!execPath) throw new Error("Chromium executable not found");

          const extPath = path.resolve("node_modules/puppeteer-stream/extension");
          if (!fs.existsSync(extPath)) throw new Error(`extension not found: ${extPath}`);

          // IMPORTANT:
          // - run headful (extensions are unreliable in headless)
          // - workflow step uses xvfb-run
          const browser = await puppeteer.launch({
            executablePath: execPath,
            headless: false,
            ignoreDefaultArgs: ["--disable-extensions"],
            args: [
              "--no-sandbox",
              "--disable-setuid-sandbox",
              "--disable-dev-shm-usage",
              `--window-size=${w},${h}`,
              `--disable-extensions-except=${extPath}`,
              `--load-extension=${extPath}`,
            ],
          });

          const page = await browser.newPage();
          page.setDefaultNavigationTimeout(120000);
          page.setDefaultTimeout(120000);
          await page.setViewport({ width: w, height: h, deviceScaleFactor: 1 });

          page.on("console", (msg) => console.log("PAGE:", msg.text()));
          page.on("pageerror", (err) => console.log("PAGEERR:", String(err)));

          const url = `file://${process.cwd()}/web/scene.html?w=${w}&h=${h}&text=${encodeURIComponent(text)}`;

          console.log("goto...");
          await page.goto(url, { waitUntil: "domcontentloaded", timeout: 120000 });

          console.log("inject bg + reload...");
          await page.evaluate((b)=>{ window.__BG__ = b; }, bgDataUrl);
          await page.reload({ waitUntil: "domcontentloaded", timeout: 120000 });

          await new Promise(r => setTimeout(r, 1500));

          console.log("getStream...");
          const stream = await getStream(page, {
            audio: false,
            video: true,
            timeout: 120000,
            mimeType: "video/webm;codecs=vp8",
            videoBitsPerSecond: 2_500_000,
          });

          const outPath = mode === "youtube" ? "work/loop_youtube.webm" : "work/loop_tiktok.webm";
          const file = fs.createWriteStream(outPath);
          stream.pipe(file);

          console.log("recording 60s...");
          await new Promise(r => setTimeout(r, 60_000));

          console.log("stop...");
          await stream.destroy();
          file.close();

          await browser.close();
          (await wss).close();

          console.log("OK", outPath);
          JS

      - name: Record 60s loop videos (tiktok + youtube) [no frames]
        run: |
          set -euo pipefail
          xvfb-run -a node scripts/record_60s.mjs tiktok
          xvfb-run -a node scripts/record_60s.mjs youtube

      - name: Convert loop webm -> loop mp4
        run: |
          set -euo pipefail
          ffmpeg -y -i work/loop_tiktok.webm \
            -c:v libx264 -pix_fmt yuv420p -preset veryfast -crf 20 work/loop_tiktok.mp4
          ffmpeg -y -i work/loop_youtube.webm \
            -c:v libx264 -pix_fmt yuv420p -preset veryfast -crf 20 work/loop_youtube.mp4

      - name: Loop video to match audio + mux audio (TikTok)
        run: |
          set -euo pipefail
          ffmpeg -y -stream_loop -1 -i work/loop_tiktok.mp4 -i work/tts.mp3 \
            -c:v copy -c:a aac -b:a 192k -shortest work/tiktok.mp4

      - name: Loop video to match audio + mux audio (YouTube)
        run: |
          set -euo pipefail
          ffmpeg -y -stream_loop -1 -i work/loop_youtube.mp4 -i work/tts.mp3 \
            -c:v copy -c:a aac -b:a 192k -shortest work/youtube.mp4

      - name: Upload to Telegram (caption = date + summary short)
        env:
          TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
          TITLE: ${{ steps.prep.outputs.title }}
        run: |
          set -euo pipefail
          CAPTION="$TITLE"
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendVideo" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F video=@work/tiktok.mp4 | jq .
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendVideo" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F video=@work/youtube.mp4 | jq .
          curl -sS -X POST "https://api.telegram.org/bot${TG_BOT_TOKEN}/sendDocument" \
            -F chat_id="$TG_CHAT_ID" \
            -F caption="$CAPTION" \
            -F document=@work/upload.txt | jq .

      - name: Upload artifacts (optional)
        uses: actions/upload-artifact@v4
        with:
          name: outputs
          path: |
            work/tts.mp3
            work/loop_tiktok.webm
            work/loop_youtube.webm
            work/loop_tiktok.mp4
            work/loop_youtube.mp4
            work/tiktok.mp4
            work/youtube.mp4
            work/upload.txt

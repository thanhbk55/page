name: YouTube Upload

on:
  workflow_dispatch:
    inputs:
      gdrive_rel_path:
        description: "Relative path inside Drive folder (e.g. folder-a/video.mp4)"
        required: true
      yt_title:
        description: "YouTube title"
        required: true
      yt_description:
        description: "YouTube description"
        required: true
      yt_privacy:
        description: "private|unlisted|public"
        required: false
        default: "private"

jobs:
  download:
    runs-on: ubuntu-latest
    env:
      # Dùng bộ YT_* làm OAuth để tải Drive (refresh token PHẢI có drive.readonly scope)
      GOOGLE_CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
      GOOGLE_CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
      GOOGLE_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}

      GDRIVE_FOLDER_ID: ${{ secrets.GDRIVE_FOLDER_ID }}
      OUT_PATH: "out/video.mp4"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps
        run: npm i googleapis@^140

      - name: Download from Google Drive
        env:
          GDRIVE_REL_PATH: ${{ inputs.gdrive_rel_path }}
        run: |
          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const { google } = require("googleapis");

          const clientId = process.env.GOOGLE_CLIENT_ID;
          const clientSecret = process.env.GOOGLE_CLIENT_SECRET;
          const refreshToken = process.env.GOOGLE_REFRESH_TOKEN;

          const rootFolderId = process.env.GDRIVE_FOLDER_ID;
          const relPath = process.env.GDRIVE_REL_PATH;
          const outPath = process.env.OUT_PATH || "out/video.mp4";

          if (!clientId || !clientSecret || !refreshToken) {
            throw new Error("Missing GOOGLE_CLIENT_ID / GOOGLE_CLIENT_SECRET / GOOGLE_REFRESH_TOKEN");
          }
          if (!rootFolderId) throw new Error("Missing GDRIVE_FOLDER_ID");
          if (!relPath) throw new Error("Missing gdrive_rel_path input");

          const parts = relPath.split("/").filter(Boolean);
          if (parts.length < 1) throw new Error("Invalid gdrive_rel_path");

          const oauth2 = new google.auth.OAuth2(clientId, clientSecret);
          oauth2.setCredentials({ refresh_token: refreshToken });
          const drive = google.drive({ version: "v3", auth: oauth2 });

          async function findChild(parentId, name, mimeType) {
            const safeName = name.replace(/'/g, "\\'");
            const q = [
              `'${parentId}' in parents`,
              `name = '${safeName}'`,
              "trashed = false",
              mimeType ? `mimeType = '${mimeType}'` : null,
            ].filter(Boolean).join(" and ");

            const res = await drive.files.list({
              q,
              fields: "files(id,name,mimeType)",
              pageSize: 10,
              supportsAllDrives: true,
              includeItemsFromAllDrives: true,
            });

            return res.data.files?.[0] || null;
          }

          async function main() {
            let currentFolderId = rootFolderId;

            // Walk folders
            for (let i = 0; i < parts.length - 1; i++) {
              const folderName = parts[i];
              const folder = await findChild(
                currentFolderId,
                folderName,
                "application/vnd.google-apps.folder"
              );
              if (!folder) throw new Error(`Folder not found: ${folderName}`);
              currentFolderId = folder.id;
            }

            const fileName = parts[parts.length - 1];
            const file = await findChild(currentFolderId, fileName, null);
            if (!file) throw new Error(`File not found: ${fileName}`);

            fs.mkdirSync(path.dirname(outPath), { recursive: true });
            const dest = fs.createWriteStream(outPath);

            const res = await drive.files.get(
              { fileId: file.id, alt: "media", supportsAllDrives: true },
              { responseType: "stream" }
            );

            await new Promise((resolve, reject) => {
              res.data.on("end", resolve).on("error", reject).pipe(dest);
            });

            console.log("Downloaded OK:", outPath);
            console.log("Drive fileId:", file.id);
          }

          main().catch((e) => {
            console.error(e);
            process.exit(1);
          });
          NODE

      - name: Verify file
        run: |
          ls -lah out
          file out/video.mp4 || true

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: video-file
          path: out/video.mp4

  upload:
    runs-on: ubuntu-latest
    needs: download

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: video-file
          path: out

      - name: Verify artifact
        run: |
          ls -lah out
          file out/video.mp4 || true

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get access token from refresh token
        id: token
        env:
          CLIENT_ID: ${{ secrets.YT_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.YT_CLIENT_SECRET }}
          REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          RESP=$(curl -sS -X POST https://oauth2.googleapis.com/token \
            -H "Content-Type: application/x-www-form-urlencoded" \
            --data-urlencode "client_id=${CLIENT_ID}" \
            --data-urlencode "client_secret=${CLIENT_SECRET}" \
            --data-urlencode "refresh_token=${REFRESH_TOKEN}" \
            --data-urlencode "grant_type=refresh_token")

          echo "$RESP" | jq .
          ACCESS_TOKEN=$(echo "$RESP" | jq -r '.access_token // empty')

          if [ -z "$ACCESS_TOKEN" ]; then
            echo "Failed to get access_token"
            exit 1
          fi

          echo "access_token=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"

      - name: Upload to YouTube (resumable)
        env:
          YT_ACCESS_TOKEN: ${{ steps.token.outputs.access_token }}
          YT_TITLE: ${{ inputs.yt_title }}
          YT_DESCRIPTION: ${{ inputs.yt_description }}
          YT_PRIVACY: ${{ inputs.yt_privacy }}
        run: |
          set -euo pipefail

          # Normalize + fallback privacy
          YT_PRIVACY="${YT_PRIVACY:-private}"
          YT_PRIVACY="$(echo "$YT_PRIVACY" | tr '[:upper:]' '[:lower:]')"
          if [[ "$YT_PRIVACY" != "private" && "$YT_PRIVACY" != "unlisted" && "$YT_PRIVACY" != "public" ]]; then
            echo "Invalid yt_privacy: $YT_PRIVACY"
            exit 1
          fi

          VIDEO_PATH="out/video.mp4"
          if [ ! -f "$VIDEO_PATH" ]; then
            echo "Video not found at $VIDEO_PATH"
            exit 1
          fi

          FILE_SIZE=$(wc -c < "$VIDEO_PATH" | tr -d ' ')
          echo "File size: $FILE_SIZE bytes"
          echo "Token prefix: ${YT_ACCESS_TOKEN:0:4}"

          # 1) Initiate resumable upload session
          curl -sS -D /tmp/yt_init_headers.txt -o /tmp/yt_init_body.json \
            -X POST \
            -H "Authorization: Bearer ${YT_ACCESS_TOKEN}" \
            -H "Content-Type: application/json; charset=UTF-8" \
            -H "X-Upload-Content-Length: ${FILE_SIZE}" \
            -H "X-Upload-Content-Type: video/*" \
            "https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status" \
            -d "$(jq -n \
              --arg title "$YT_TITLE" \
              --arg desc "$YT_DESCRIPTION" \
              --arg privacy "$YT_PRIVACY" \
              '{snippet:{title:$title,description:$desc,categoryId:"22"},status:{privacyStatus:$privacy}}' \
            )"

          UPLOAD_URL=$(grep -i '^Location:' /tmp/yt_init_headers.txt | awk '{print $2}' | tr -d '\r')
          if [ -z "${UPLOAD_URL:-}" ]; then
            echo "Failed to get resumable upload URL"
            echo "Init response headers:"
            cat /tmp/yt_init_headers.txt || true
            echo "Init response body:"
            cat /tmp/yt_init_body.json || true
            exit 1
          fi

          echo "Resumable URL acquired."

          # 2) Upload the media bytes
          HTTP_CODE=$(curl -sS -o /tmp/yt_upload_resp.json -w "%{http_code}" \
            -X PUT \
            -H "Authorization: Bearer ${YT_ACCESS_TOKEN}" \
            -H "Content-Length: ${FILE_SIZE}" \
            -H "Content-Type: video/*" \
            --data-binary @"${VIDEO_PATH}" \
            "${UPLOAD_URL}")

          echo "Upload HTTP status: $HTTP_CODE"
          cat /tmp/yt_upload_resp.json || true

          if [ "$HTTP_CODE" -lt 200 ] || [ "$HTTP_CODE" -ge 300 ]; then
            echo "Upload failed."
            exit 1
          fi

          VIDEO_ID=$(jq -r '.id // empty' /tmp/yt_upload_resp.json)
          if [ -z "$VIDEO_ID" ]; then
            echo "Upload succeeded but no video id returned (unexpected)."
            exit 1
          fi

          echo "Uploaded video id: ${VIDEO_ID}"
          echo "Video URL: https://www.youtube.com/watch?v=${VIDEO_ID}"
